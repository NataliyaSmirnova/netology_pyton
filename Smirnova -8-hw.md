
# Задание 1
### Посчитайте среднее время жизни пользователей, которые выставили более 100 оценок. Под временем жизни понимается разница между максимальным и минимальным значением столбца timestamp для данного значения userId



```python
import pandas as pd
```


```python
ratings = pd.read_csv(r'C:\Users\Natalia\Documents\Аналитик данных\Pyton\Практика\ratings_small.csv')
ratings.head()
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>userId</th>
      <th>movieId</th>
      <th>rating</th>
      <th>timestamp</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>1</td>
      <td>1</td>
      <td>4.0</td>
      <td>964982703</td>
    </tr>
    <tr>
      <th>1</th>
      <td>1</td>
      <td>3</td>
      <td>4.0</td>
      <td>964981247</td>
    </tr>
    <tr>
      <th>2</th>
      <td>1</td>
      <td>6</td>
      <td>4.0</td>
      <td>964982224</td>
    </tr>
    <tr>
      <th>3</th>
      <td>1</td>
      <td>47</td>
      <td>5.0</td>
      <td>964983815</td>
    </tr>
    <tr>
      <th>4</th>
      <td>1</td>
      <td>50</td>
      <td>5.0</td>
      <td>964982931</td>
    </tr>
  </tbody>
</table>
</div>




```python
ratings_grouped= ratings.groupby('userId').count().reset_index()
ratings_filtered = ratings_grouped [(ratings_grouped['rating'] >=100)]
film_fans_user_ids = ratings_filtered['userId'].tolist()
active_users_score = ratings[ ratings['userId'].isin(film_fans_user_ids) ]
min_max_ts= active_users_score.groupby('userId').agg(['min', 'max'])['timestamp']
print ('Средняя продолжительность жизни пользователей, поставивших не менее 100 оценок -' , 
       (round((((min_max_ts['max'] - min_max_ts['min']).mean())/3600/24),)),' дней')

```

    Средняя продолжительность жизни пользователей, поставивших не менее 100 оценок - 511  дней
    

# Задание 2
### Дана статистика услуг перевозок клиентов компании по типам (см. файл с кодом занятия). Необходимо сформировать две таблицы:
 - таблицу с тремя типами выручки для каждого client_id без указания адреса клиента
 - аналогичную таблицу по типам выручки с указанием адреса клиента

 Обратите внимание, что в процессе объединения таблиц данные не должны теряться.



```python
rzd = pd.DataFrame(
    {
        'client_id': [111, 112, 113, 114, 115],
        'rzd_revenue': [1093, 2810, 10283, 5774, 981]
    }
)
```


```python
auto = pd.DataFrame(
    {
        'client_id': [113, 114, 115, 116, 117],
        'auto_revenue': [57483, 83, 912, 4834, 98]
    }
)
```


```python

air = pd.DataFrame(
    {
        'client_id': [115, 116, 117, 118],
        'air_revenue': [81, 4, 13, 173]
    }
)
```


```python
client_base = pd.DataFrame(
    {
        'client_id': [111, 112, 113, 114, 115, 116, 117, 118],
        'address': ['Комсомольская 4', 'Энтузиастов 8а', 'Левобережная 1а', 'Мира 14', 'ЗЖБИиДК 1', 
                    'Строителей 18', 'Панфиловская 33', 'Мастеркова 4']
    }
)
client_base
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>client_id</th>
      <th>address</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>111</td>
      <td>Комсомольская 4</td>
    </tr>
    <tr>
      <th>1</th>
      <td>112</td>
      <td>Энтузиастов 8а</td>
    </tr>
    <tr>
      <th>2</th>
      <td>113</td>
      <td>Левобережная 1а</td>
    </tr>
    <tr>
      <th>3</th>
      <td>114</td>
      <td>Мира 14</td>
    </tr>
    <tr>
      <th>4</th>
      <td>115</td>
      <td>ЗЖБИиДК 1</td>
    </tr>
    <tr>
      <th>5</th>
      <td>116</td>
      <td>Строителей 18</td>
    </tr>
    <tr>
      <th>6</th>
      <td>117</td>
      <td>Панфиловская 33</td>
    </tr>
    <tr>
      <th>7</th>
      <td>118</td>
      <td>Мастеркова 4</td>
    </tr>
  </tbody>
</table>
</div>




```python
revenue_data = air.merge(auto, how='outer', on='client_id').merge(rzd, how='outer', on='client_id').sort_values(['client_id'])
revenue_data
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>client_id</th>
      <th>air_revenue</th>
      <th>auto_revenue</th>
      <th>rzd_revenue</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>6</th>
      <td>111</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>1093.0</td>
    </tr>
    <tr>
      <th>7</th>
      <td>112</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>2810.0</td>
    </tr>
    <tr>
      <th>4</th>
      <td>113</td>
      <td>NaN</td>
      <td>57483.0</td>
      <td>10283.0</td>
    </tr>
    <tr>
      <th>5</th>
      <td>114</td>
      <td>NaN</td>
      <td>83.0</td>
      <td>5774.0</td>
    </tr>
    <tr>
      <th>0</th>
      <td>115</td>
      <td>81.0</td>
      <td>912.0</td>
      <td>981.0</td>
    </tr>
    <tr>
      <th>1</th>
      <td>116</td>
      <td>4.0</td>
      <td>4834.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>2</th>
      <td>117</td>
      <td>13.0</td>
      <td>98.0</td>
      <td>NaN</td>
    </tr>
    <tr>
      <th>3</th>
      <td>118</td>
      <td>173.0</td>
      <td>NaN</td>
      <td>NaN</td>
    </tr>
  </tbody>
</table>
</div>




```python
full_data= revenue_data.merge(client_base, how='left', on='client_id')
full_data
```




<div>
<style scoped>
    .dataframe tbody tr th:only-of-type {
        vertical-align: middle;
    }

    .dataframe tbody tr th {
        vertical-align: top;
    }

    .dataframe thead th {
        text-align: right;
    }
</style>
<table border="1" class="dataframe">
  <thead>
    <tr style="text-align: right;">
      <th></th>
      <th>client_id</th>
      <th>air_revenue</th>
      <th>auto_revenue</th>
      <th>rzd_revenue</th>
      <th>address</th>
    </tr>
  </thead>
  <tbody>
    <tr>
      <th>0</th>
      <td>111</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>1093.0</td>
      <td>Комсомольская 4</td>
    </tr>
    <tr>
      <th>1</th>
      <td>112</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>2810.0</td>
      <td>Энтузиастов 8а</td>
    </tr>
    <tr>
      <th>2</th>
      <td>113</td>
      <td>NaN</td>
      <td>57483.0</td>
      <td>10283.0</td>
      <td>Левобережная 1а</td>
    </tr>
    <tr>
      <th>3</th>
      <td>114</td>
      <td>NaN</td>
      <td>83.0</td>
      <td>5774.0</td>
      <td>Мира 14</td>
    </tr>
    <tr>
      <th>4</th>
      <td>115</td>
      <td>81.0</td>
      <td>912.0</td>
      <td>981.0</td>
      <td>ЗЖБИиДК 1</td>
    </tr>
    <tr>
      <th>5</th>
      <td>116</td>
      <td>4.0</td>
      <td>4834.0</td>
      <td>NaN</td>
      <td>Строителей 18</td>
    </tr>
    <tr>
      <th>6</th>
      <td>117</td>
      <td>13.0</td>
      <td>98.0</td>
      <td>NaN</td>
      <td>Панфиловская 33</td>
    </tr>
    <tr>
      <th>7</th>
      <td>118</td>
      <td>173.0</td>
      <td>NaN</td>
      <td>NaN</td>
      <td>Мастеркова 4</td>
    </tr>
  </tbody>
</table>
</div>



# Задание 3
### В задаче сквозной аналитики вам предоставили данные по местоположению пользователей. Т. е. для каждого user_id известна последовательность координат (широта/долгота), когда они требовались приложению для полноценной работы. Как бы вы добавили эти сведения в таблицу визитов и покупок?


### Вариант 1 (если нам нужно узнать, где был пользователь в момент покупки):
Для этой задачи нам нужно, чтобы  в таблице визитов и покупок, а также в данных о геолокации была информация о времени. 
Можно  данные по местоположению записать в словарь в виде датафрейма. В этом датафрейме каждому уникальному пользователю соответствовало бы время, когда были определены его координаты, и сами координаты. То есть если пользователь несколько раз пользовался приложением, то мы можем узнать, когда и где он это делал.
Соединять две таблицы нужно было по user_id и timestamp (выбираем ту строчку, в которых разница между временем совершения покупки и временем определения координат была минимальна).

#### Минусы: 
при большом количестве пользователей и частом использовании приложения каждым из них, объем данных будет потенциально большим.

### Вариант 2 (информации о времени нет, только набор координат при каждом пользовании приложением):
Если нам нужно понять, где чаще всего бывает потребитель, то нужно посчитать количество одинаковых координат у каждого пользователя и при объединении таблиц выводить наиболее частый вариант. При этом если координаты для каждого пользователя определяются с точностью до нескольких метров, можно перед подсчетом одинаковых координат поработать с их значениями. А именно каждой координате присвоить значение координат района или города( в зависимости от задачи), или же просто убрать значения секунд в координатах, оставив лишь градусы и минуты. То есть если пользователь определил свое положение, потом прошел 500 метров и опять произошла запись координат, то после обработки данных эти 2 координаты будут распознаны как одинаковые.

#### Минусы:

1. В данном случае наиболее частое место "обитания" - вещь условная. Если у пользователь 51% определенных локаций дома, а 49%- на работе, на другом конце города, то определение домашней координаты может не отвечать нашим задачам. Кроме того здесь еще много зависит от работы самого приложения и как там идет запись координат (автоматически через равные промежутки времени или же только тогда, когда пользователь заходит в приложение. если 2 вариант, то Мб если бы на работе у пользователя было бы больше свободного времени, он чаще бы заходил бы в него?) 

    Эту проблему можно решить путем записи в обобщенную таблицу не 1 показателя координат, а списка наиболее частых координат, которые соответствуют заданному условию. (допустим они попадают в топ 3 или если доля записи этих координат более 30%, а может и объединение этих условий)

2. Требуется хорошее понимание системы координат и необходима серьезная проработка подхода к округлению координат.
3. Подход к выбору координат может меняться в зависимости от задачи. Поэтому нужно четкое понимае для чего мы определеям положение пользователя.

### Вариант 3 (имеются только уникальные значения локаций):
У нас на руках данные только по уникальным координатам пользователя, и мы не можем определить с какой частотой он бывает в том или ином месте. В данном случае можно создать дополнительный датафрейм, в котором прописаны диапозоны координат интересующих нас районов. Допустим, нам интересно, в каком районе Москвы бывает пользователь. В датафреме мы прописываем названия районов и их диапозон координат  для отдельных районо. Делаем проверку на попадание пользовательских координат в диапозон координат района. При объединении данных в строках с координатами, попавшими в диапозон, добавляется столбец с названием района. Если же координаты не попали ни в один район Москвы, то добавляется пустая строка (NaN). Создаем датафрейм в котором будет 2 стобца : userID и название района, если пользователь был в нескольких районах, то в столбце районов, допустим, указывается список этих районов. При объединении с таблицей визитов/покупок по userID будет добавлен стобец с названиями районов для каждого ользователя. 

#### Минусы:
Должна быть проделана сложая работа по созданию датафрейма с названиями районов и присвоением им диапозона координат. 


### P.S. 
Очень многое зависит от самих данных( какую информацию они несут (должно быть понимание, в какой момент идет запись геоданных)) и от наших задач ( мы хотим знать, откуда у нас поступают заказы, или просто где бывают наши пользователи , или бывают ли они рядом с нашим оффлайн магазином?). Здесь представлены лишь примерные размышления на тему того, что можно получить из этих данных, и как это теоретически можно сделать. Можно с уверенностью сказать, что на практике реализация этих подходов вызовет значительный ряд трубностей.
